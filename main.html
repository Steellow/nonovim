<head>
    <style>
        table {
            margin: 20px;
        }

        .container {
            padding-left: 50px;
            padding-top: 50px;
            position: relative;
            margin: 100px
        }

        .column-titles {
            position: absolute;
            top: 0;
            left: 50px;
            display: flex;
            gap: 0;
            height: 50px;
        }

        .column-title {
            width: 50px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            border-right: 1px solid black;
            padding: 5px;
            font-size: 24px;
            font-weight: bold;
        }

        .column-title:last-child {
            border-right: none;
        }

        .row-titles {
            position: absolute;
            left: 0;
            top: 69px;
            display: flex;
            flex-direction: column;
        }

        .row-title {
            height: 50px;
            display: flex;
            align-items: center;
            padding: 0 5px;
            margin-left: 20px;
            border-bottom: 1px solid black;
            font-size: 24px;
            font-weight: bold;
        }

        .row-title:last-child {
            border-bottom: none;
        }

        table,
        td {
            border: 1px solid black;
            border-collapse: collapse;
        }

        td {
            position: relative;
            box-sizing: border-box;
            padding: 0;
            /* overflow: hidden; */
        }

        .filled {
            background-color: #2d2d2d;
            width: 100%;
            height: 100%;
        }

        .crossed {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            width: 100%;
            font-size: large;
        }

        td.focused::after {
            content: '';
            position: absolute;
            top: -5px;
            left: -5px;
            right: -5px;
            bottom: -5px;
            border: 5px solid red;
            z-index: 1;
        }
    </style>
</head>

<body>
    <script src="https://unpkg.com/mithril/mithril.js"></script>
    <script>
        // Temp
        columnNumbers = ["1", "6", "1", "2"]
        rowNumbers = ["2", "1", "1", "1", "3", "1 1"]

        // Settings
        const width = columnNumbers.length
        const height = rowNumbers.length
        const cellSize = 50

        // Helper functions
        const calcIndex = (colIndex, rowIndex) => (colIndex * width) + rowIndex

        state = {
            x: 0,
            y: 0,
            // 0 = empty, 1 = painted, 2 = crossed
            game: [
                [0, 0, 0, 0],
                [0, 0, 0, 0],
                [0, 0, 0, 0],
                [0, 0, 0, 0],
                [0, 0, 0, 0],
                [0, 0, 0, 0],
            ],
            vim: {
                repeat: 1,
                action: 0
            }
        };

        const Grid = {
            // Add event listener when component mounts
            oncreate: function () {
                document.addEventListener("keyup", this.boundHandleKeyPress);
            },

            // Clean up when component unmounts
            onremove: function () {
                document.removeEventListener("keyup", this.boundHandleKeyPress);
            },

            view: function (vnode) {
                return m("div.container",
                    [
                        m("div.column-titles",
                            columnNumbers.map((title, i) =>
                                m("div.column-title",
                                    title.split(" ").map(num => m("span", num))
                                ))
                        ),

                        m("div.row-titles",
                            rowNumbers.map(title =>
                                m("div.row-title", title)
                            )
                        ),

                        m("table",
                            Array.from({ length: height }, (_, colIndex) =>
                                m("tr",
                                    Array.from({ length: width }, (_, rowIndex) =>
                                        m("td", {
                                            style: {
                                                height: cellSize,
                                                width: cellSize,
                                                // border: this.getRedBorder(colIndex, rowIndex)
                                            },
                                            // class: 'focused'
                                            class: this.isFocused(colIndex, rowIndex)
                                        },
                                            // calcIndex(colIndex, rowIndex),
                                            this.getCellContent(colIndex, rowIndex)
                                        )
                                    )
                                )
                            )
                        )
                    ]
                )
            },

            // Component methods
            getRedBorder: function (colIndex, rowIndex) {
                return (colIndex === state.y && rowIndex === state.x)
                    ? "2px solid red"
                    : "";
            },

            isFocused: function (colIndex, rowIndex) {
                return (colIndex === state.y && rowIndex === state.x)
                    ? "focused"
                    : "temp";
            },

            getCellContent: function (colIndex, rowIndex) {
                const cellState = state.game[colIndex][rowIndex]

                if (cellState == 1) {
                    return m("div.filled")
                } else if (cellState == 2) {
                    return m("div.crossed", "X")
                }
                return null
            },

            // Move event handler into component
            handleKeyPress: function (e) {
                const isDigit = e.code.slice(0, -1) === "Digit"

                if (isDigit) {
                    console.log("Digit recognized, saving to buffer");
                    state.vim.repeat = Number(e.code.slice(-1));
                } else {

                    // Handle single action
                    if (state.vim.repeat === 1) {
                        console.log("No repeat buffer, performing single action");

                        if (e.code === "KeyJ") {
                            state.y = state.y + 1;
                        } else if (e.code === "KeyK") {
                            state.y = state.y - 1;
                        } else if (e.code === "KeyH") {
                            state.x = state.x - 1;
                        } else if (e.code === "KeyL") {
                            state.x = state.x + 1;
                        } else if (e.code === "KeyF") {
                            state.game[state.y][state.x] = 1
                        } else if (e.code === "KeyD") {
                            state.game[state.y][state.x] = 2
                        } else if (e.code === "KeyS") {
                            state.game[state.y][state.x] = 0
                        }
                        m.redraw() // .sync?
                    }


                    // Handle cursor move + action buffer
                    else if (state.vim.repeat > 1 && state.vim.action > 0) {
                        console.log("Repeat and action recognized, doing them multiple times");


                        for (let i = 0; i < state.vim.repeat; i++) {
                            state.game[state.y][state.x] = state.vim.action

                            if (i < state.vim.repeat - 1) {
                                if (e.code === "KeyJ") {
                                    state.y = state.y + 1;
                                } else if (e.code === "KeyK") {
                                    state.y = state.y - 1;
                                } else if (e.code === "KeyH") {
                                    state.x = state.x - 1;
                                } else if (e.code === "KeyL") {
                                    state.x = state.x + 1;
                                }
                            }


                        }
                        state.vim.action = 0
                        state.vim.repeat = 1
                    }

                    // Handle cursor move
                    else if (/^Key[HJKL]$/.test(e.code)) {

                        console.log("Repeat recognized, moving cursor multiple times");


                        for (let i = 0; i < state.vim.repeat; i++) {
                            if (e.code === "KeyJ") {
                                state.y = state.y + 1;
                            } else if (e.code === "KeyK") {
                                state.y = state.y - 1;
                            } else if (e.code === "KeyH") {
                                state.x = state.x - 1;
                            } else if (e.code === "KeyL") {
                                state.x = state.x + 1;
                            }
                        }

                        state.vim.repeat = 1
                        m.redraw()
                    }

                    // Handle action buffer
                    else if (state.vim.repeat > 1 && /^Key[DF]$/.test(e.code)) {
                        console.log("Repeat recognized and action pressed, saving action");


                        if (e.code === "KeyF") {
                            state.vim.action = 1
                        } else if (e.code === "KeyD") {
                            state.vim.action = 2
                        }
                    }

                }

                console.log(state.vim);
            }
        }

        // Add event listener with proper context binding
        document.addEventListener("keyup", (e) => {
            Grid.handleKeyPress(e);
            m.redraw.sync(); // Sync with Mithril's redraw cycle
        });

        m.mount(document.body, Grid)
    </script>
</body>