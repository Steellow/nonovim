<head>
    <style>
        /* Reset or basic styles */
        body {
            font-family: sans-serif;
        }

        table,
        td {
            border-collapse: collapse;
        }

        /* Keep collapse */

        /* Container holds everything */
        .container {
            position: relative;
            /* Crucial for absolute positioning of children */
            /* padding-top, padding-left, and margin will be set inline */
            /* border: 1px dashed gray; */
            /* Optional: for debugging */
        }

        /* Column Titles container */
        .column-titles {
            position: absolute;
            /* top, left, height set inline */
            display: flex;
            /* Add border to separate from table cells */
            border-bottom: 1px solid black;
            box-sizing: border-box;
            /* background-color: rgba(255,0,0,0.1); */
            /* Debugging */
        }

        /* Individual Column Title */
        .column-title {
            /* width set inline (cellSize) */
            height: 100%;
            /* Takes height from .column-titles container */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            border-right: 1px solid black;
            box-sizing: border-box;
            /* Width includes border/padding */
            padding: 5px;
            font-size: 18px;
            /* Smaller font might be needed */
            font-weight: bold;
            overflow: hidden;
        }

        .column-title:last-child {
            border-right: none;
            /* No border on the far right */
        }

        /* Row Titles container */
        .row-titles {
            position: absolute;
            /* top, left, width set inline */
            display: flex;
            flex-direction: column;
            /* Add border to separate from table cells */
            border-right: 1px solid black;
            box-sizing: border-box;
            /* background-color: rgba(0,255,0,0.1); */
            /* Debugging */
        }

        /* Individual Row Title */
        .row-title {
            /* height set inline (cellSize) */
            width: 100%;
            /* Takes width from .row-titles container */
            display: flex;
            align-items: center;
            justify-content: flex-end;
            /* Align text to the right */
            border-bottom: 1px solid black;
            box-sizing: border-box;
            /* Height includes border/padding */
            padding: 0 5px;
            font-size: 18px;
            font-weight: bold;
            overflow: hidden;
        }

        .row-title:last-child {
            border-bottom: none;
            /* No border at the very bottom */
        }

        /* Style for highlighted titles */
        .highlighted-title {
            background-color: #e8e849;
            /* Light yellow background */
            /* You could also add other styles like: */
            /* font-weight: bolder; */
            /* transition: background-color 0.1s ease-in-out; */
            /* Optional smooth transition */
        }

        /* Table - positioned by container padding */
        table {
            border-collapse: collapse;
            /* border-top and border-left needed to complete the box */
            /* These will align with the bottom/right borders of the title containers */
            border-top: 1px solid black;
            border-left: 1px solid black;
            margin: 0;
            /* Remove default table margin */
            /* background-color: rgba(0,0,255,0.1); */
            /* Debugging */
        }

        /* Table Cell */
        td {
            /* height, width set inline (cellSize) */
            border: 1px solid black;
            position: relative;
            /* For focus pseudo-element */
            box-sizing: border-box;
            /* Critical for size including border */
            padding: 0;
        }

        /* Cell Content Styles (Unchanged) */
        .filled {
            background-color: #2d2d2d;
            width: 100%;
            height: 100%;
        }

        .crossed {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            width: 100%;
            font-size: large;
            color: #555;
        }

        /* Focus Style (Unchanged) */
        td.focused::after {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            border: 3px solid red;
            z-index: 1;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <script src="https://unpkg.com/mithril/mithril.js"></script>
    <script>
        // Temp
        const columnNumbers = ["1", "6", "1", "2"];
        const rowNumbers = ["2", "1", "1", "1", "3", "1 1"];


        // Settings
        const width = columnNumbers.length;
        const height = rowNumbers.length;
        const cellSize = 50; // Change this value to test scaling
        const colTitleHeight = 50; // How tall the column title area is
        const rowTitleWidth = 50;  // How wide the row title area is
        const outerMargin = 50; // Margin around the whole puzzle



        const state = {
            x: 0, // Represents column index
            y: 0, // Represents row index
            // 0 = empty, 1 = painted, 2 = crossed
            game: Array.from({ length: height }, () => Array(width).fill(0)), // Initialize game grid correctly
            vim: {
                repeat: 1,
                action: 0 // 0=none, 1=fill(F), 2=cross(D)
            }
        };

        const Grid = {
            // No need for oncreate/onremove if using a global listener below
            // that calls Grid.handleKeyPress directly.
            view: function (vnode) {
                // --- Calculate Styles ---

                // Container needs padding for titles and outer margin
                const containerStyle = {
                    paddingTop: `${colTitleHeight}px`,
                    paddingLeft: `${rowTitleWidth}px`,
                    margin: `${outerMargin}px` // Use the constant for outer margin
                };

                // Column titles positioned at top-left corner of the PADDED area
                const colTitlesStyle = {
                    top: '0px', // Align to container's top edge
                    left: `${rowTitleWidth}px`, // Start after the row title space
                    height: `${colTitleHeight}px` // Use constant height
                    // border-bottom is in CSS
                };

                // Row titles positioned below col titles, at left edge
                const rowTitlesStyle = {
                    top: `${colTitleHeight}px`, // Start below the column title space
                    left: '0px', // Align to container's left edge
                    width: `${rowTitleWidth}px` // Use constant width
                    // border-right is in CSS
                };
                return m("div.container", { style: containerStyle },
                    [
                        // Column Titles Area (Absolute)
                        m("div.column-titles", { style: colTitlesStyle },
                            columnNumbers.map((title, colIndex) => // Get column index 'colIndex'
                                m("div.column-title", // Base class
                                    {
                                        // Set width based on cellSize
                                        style: { width: `${cellSize}px` },
                                        // Conditionally add highlight class
                                        class: colIndex === state.x ? 'highlighted-title' : ''
                                    },
                                    title.split(" ").map(num => m("span", num))
                                ))
                        ),

                        // Row Titles Area (Absolute)
                        m("div.row-titles", { style: rowTitlesStyle },
                            rowNumbers.map((title, rowIndex) => // Get row index 'rowIndex'
                                m("div.row-title", // Base class
                                    {
                                        // Set height based on cellSize
                                        style: { height: `${cellSize}px` },
                                        // Conditionally add highlight class
                                        class: rowIndex === state.y ? 'highlighted-title' : ''
                                    },
                                    title
                                )
                            )
                        ),

                        // Table (positions itself in the container's content-box)
                        m("table",
                            // ... (rest of the table rendering remains the same)
                            { style: { margin: 0 } },
                            Array.from({ length: height }, (_, rowIndex) =>
                                m("tr",
                                    Array.from({ length: width }, (_, colIndex) =>
                                        m("td", {
                                            // Set width and height based on cellSize
                                            style: {
                                                height: `${cellSize}px`,
                                                width: `${cellSize}px`,
                                            },
                                            // IMPORTANT: Ensure focus class is still applied correctly
                                            class: this.isFocused(rowIndex, colIndex) ? "focused" : ""
                                        },
                                            this.getCellContent(rowIndex, colIndex)
                                        )
                                    )
                                )
                            )
                        )
                    ]
                )
            },

            // Component methods
            // getRedBorder: function (rowIndex, colIndex) { // Updated params
            //     return (rowIndex === state.y && colIndex === state.x)
            //         ? "2px solid red"
            //         : "";
            // },

            isFocused: function (rowIndex, colIndex) { // Updated params
                return (rowIndex === state.y && colIndex === state.x);
            },

            getCellContent: function (rowIndex, colIndex) { // Updated params
                // Ensure rowIndex and colIndex are within bounds before accessing state.game
                if (rowIndex >= 0 && rowIndex < height && colIndex >= 0 && colIndex < width) {
                    const cellState = state.game[rowIndex][colIndex];
                    if (cellState === 1) {
                        return m("div.filled");
                    } else if (cellState === 2) {
                        return m("div.crossed", "X");
                    }
                }
                return null; // Return null if out of bounds or empty
            },

            // Event handler - NO 'this' context needed if called directly
            handleKeyPress: function (e) {
                const isDigit = e.code.startsWith("Digit") && e.code !== "Digit0";

                // 1. Handle Digits First
                if (isDigit) {
                    const digit = Number(e.code.slice(-1));
                    // If no action is pending and repeat is 1, start a new repeat count.
                    // Otherwise, append to the existing repeat count.
                    if (state.vim.action === 0 && state.vim.repeat === 1) {
                        state.vim.repeat = digit;
                    } else {
                        // Append digit (e.g., 1 then 2 becomes 12)
                        state.vim.repeat = state.vim.repeat * 10 + digit;
                    }
                    console.log("Digit recognized, repeat set to:", state.vim.repeat);
                    // Wait for the next key (action or move)
                    return;
                }

                // --- Define Key Types ---
                let dx = 0;
                let dy = 0;
                let isMoveKey = false;
                if (e.code === "KeyJ") { dy = 1; isMoveKey = true; }
                else if (e.code === "KeyK") { dy = -1; isMoveKey = true; }
                else if (e.code === "KeyH") { dx = -1; isMoveKey = true; }
                else if (e.code === "KeyL") { dx = 1; isMoveKey = true; }

                let isFillActionKey = false;
                let isCrossActionKey = false;
                let isClearActionKey = false; // Renamed from isClearKey for consistency
                let pendingActionType = 0; // 0=none, 1=fill, 2=cross, 3=clear (pending)

                if (e.code === "KeyF") { isFillActionKey = true; pendingActionType = 1; }
                else if (e.code === "KeyD") { isCrossActionKey = true; pendingActionType = 2; }
                else if (e.code === "KeyS") { isClearActionKey = true; pendingActionType = 3; } // S now sets pending action type 3

                let needsRedraw = false;

                // 2. Handle Action Keys (F, D, S)
                // Combine F/D/S handling for pending state
                if (isFillActionKey || isCrossActionKey || isClearActionKey) {
                    const immediateActionValue = pendingActionType === 3 ? 0 : pendingActionType; // S(3) maps to state 0

                    // If repeat is 1 (meaning no number preceded action key),
                    // apply the action immediately and reset vim state.
                    if (state.vim.repeat === 1) {
                        console.log(`Immediate action: ${pendingActionType} (Applying state ${immediateActionValue})`);
                        if (state.y >= 0 && state.y < height && state.x >= 0 && state.x < width) {
                            if (state.game[state.y][state.x] !== immediateActionValue) {
                                state.game[state.y][state.x] = immediateActionValue;
                                needsRedraw = true;
                            }
                        }
                        // Reset state completely after immediate action
                        state.vim.action = 0;
                        state.vim.repeat = 1;
                    } else {
                        // If repeat > 1 (e.g., '3f', '3s'), store the action type and wait for a move key.
                        state.vim.action = pendingActionType; // Store 1, 2, or 3
                        console.log(`Action ${state.vim.action} pending, repeat ${state.vim.repeat}, waiting for direction...`);
                        // Don't reset repeat here, it's needed for the move key.
                    }
                }
                // 3. Handle Movement Keys (H, J, K, L)
                else if (isMoveKey) {
                    // Check if an action is pending (from a preceding F/D/S key with repeat > 1)
                    if (state.vim.action > 0) {
                        // Determine the actual game state value to apply based on the pending action
                        const actualActionToApply = state.vim.action === 3 ? 0 : state.vim.action; // Map pending clear(3) to state 0

                        // Execute <action><num><direction> sequence
                        console.log(`Executing pending action ${state.vim.action} (Apply: ${actualActionToApply}), repeat ${state.vim.repeat}, direction ${dx},${dy}`);
                        for (let i = 0; i < state.vim.repeat; i++) {
                            // Apply action at current position
                            if (state.y >= 0 && state.y < height && state.x >= 0 && state.x < width) {
                                if (state.game[state.y][state.x] !== actualActionToApply) {
                                    state.game[state.y][state.x] = actualActionToApply;
                                    needsRedraw = true;
                                }
                            } else {
                                console.warn("Attempted action outside bounds - stopping repeat.");
                                break; // Stop if current pos is somehow out of bounds
                            }

                            // Move for the next iteration (if not the last one)
                            if (i < state.vim.repeat - 1) {
                                const nextX = state.x + dx;
                                const nextY = state.y + dy;
                                let movedThisIteration = false;
                                // Check bounds *before* updating state.x/state.y
                                if (dx !== 0 && nextX >= 0 && nextX < width) {
                                    state.x = nextX;
                                    movedThisIteration = true;
                                }
                                // Check Y boundary independently, applying if valid
                                if (dy !== 0 && nextY >= 0 && nextY < height) {
                                    state.y = nextY;
                                    movedThisIteration = true; // It counts as moved even if only one direction was valid
                                }

                                // If we intended to move (dx or dy was non-zero) but didn't actually change position
                                // (because both nextX and nextY were out of bounds), stop the loop.
                                if (!movedThisIteration && (dx !== 0 || dy !== 0)) {
                                    console.log("Hit boundary during action+move repeat - stopping.");
                                    needsRedraw = true; // Need redraw to show final focus position
                                    break;
                                }
                                needsRedraw = true; // Always need redraw if we moved
                            }
                        }
                        // Reset vim state after completion
                        state.vim.action = 0;
                        state.vim.repeat = 1;

                    } else {
                        // Execute simple <num><direction> move (no pending action)
                        console.log(`Executing move with repeat ${state.vim.repeat} and direction ${dx},${dy}`);
                        for (let i = 0; i < state.vim.repeat; i++) {
                            const nextX = state.x + dx;
                            const nextY = state.y + dy;
                            let movedThisIteration = false;
                            // Check bounds *before* updating
                            if (dx !== 0 && nextX >= 0 && nextX < width) {
                                state.x = nextX;
                                movedThisIteration = true;
                            }
                            if (dy !== 0 && nextY >= 0 && nextY < height) {
                                state.y = nextY;
                                movedThisIteration = true;
                            }
                            // If trying to move but couldn't (hit boundary), stop the loop.
                            if (!movedThisIteration && (dx !== 0 || dy !== 0)) {
                                console.log("Hit boundary during move repeat - stopping.");
                                needsRedraw = true; // Need redraw to show final focus position
                                break;
                            }
                            needsRedraw = true; // Always need redraw if we moved
                        }
                        // Reset only repeat count after simple move
                        state.vim.repeat = 1;
                    }
                }
                // 4. Handle Other Keys (Not digit, action, or move)
                else {
                    // Any other key resets the pending action and repeat count
                    if (!isDigit) { // Digits already handled
                        if (state.vim.repeat !== 1 || state.vim.action !== 0) {
                            console.log("Non-vim sequence key pressed, resetting vim state.");
                            state.vim.action = 0;
                            state.vim.repeat = 1;
                        }
                    }
                }

                // Redraw if necessary
                if (needsRedraw) {
                    m.redraw();
                }

                console.log("End state -> x:", state.x, "y:", state.y, "Repeat:", state.vim.repeat, "Action:", state.vim.action);
            }
        }

        // Global event listener
        document.addEventListener("keyup", (e) => {
            Grid.handleKeyPress(e);
            // m.redraw() is now called inside handleKeyPress if needed
        });

        m.mount(document.body, Grid);

    </script>
</body>